# CF325E The Red Button（哈密顿欧拉回路状物）

我逐渐理解一切.png

NOIp 模拟赛考到这道题，没想到是 2800 的。

**Warning：此篇题解包含 $3$ 种做法，篇幅较长。**

题意相当于在特殊的 $n$ 个点 $2n$ 条边的有向图中找哈密顿回路。

首先 $n$ 为奇数无解，通过观察 $0$ 和 $n-1$ 的连边就可以发现。

然后我们对于 $n$ 为偶数的情况构造，同时证明了解的存在性。

不妨设 $m=\frac{n}{2}$。

首先我们有一个较显然但是关键的性质：

考虑 $x,x+m,2x,2x+1$ 四个值在模 $n$ 意义下对应的图的节点，分别设为 $A,B,C,D$。

注意 $A,B,C,D$ 可能指代相同的点，但是 $A,B$ 不可能相同，$C,D$ 不可能相同。

观察 $A,B$ 的出边和 $C,D$ 的入边，发现都只有这相同的 $4$ 条边：

![](https://cdn.luogu.com.cn/upload/image_hosting/1cml5stw.png)

上图最终存在于哈密顿回路中的边只有两种情况：
$$A\to C,B\to D\quad(1)$$
和 
$$A\to D,B\to C\quad(2)$$
我们称 $\forall x\in[0,m)\cap\mathbb Z,(x,x+m)$ 为一个**组合**。

对于每一个组合作为上图的 $A,B$，我们都以 $(1)$ 和 $(2)$ 中一种方式连边，这样构成的生成子图 $(\Delta)$ 一定是多个有向环的不交并（每个点出入度均为 $1$）。

接下来考虑如何将多个环合并成一个。

有一个神奇的结论：

若有 $>1$ 个环，则必存在一个组合中的两个点不在同一个环里。$\quad(*)$

证明：

反证法。若所有组合在同一环里，则组合为 $A,B$ 对应的 $C,D$ 也在同一个环里，进一步得到任意 $x\in[0,n-1]\cap\mathbb Z$ 其与 $2x\bmod n,2x+1\bmod n$ 在同一个环里，由二进制拆分，我们可以从 $0$ 开始走到任意点，所以所有点在同一个环里，矛盾，原命题成立。

所以我们先连边建并查集，然后对于每一个组合，若两者不在同一个环里，则交换出边，合并两个环即可。

[代码](https://codeforces.com/contest/325/submission/174738272)

你以为就结束了？

发现并查集还是不能做到线性（至少乘反阿克曼），我们有线性做法！

考虑一种错误的做法：

从 $0$ 节点开始暴力 dfs（不重复经过点），直到回到 $0$ 本身。

发现这样错误的原因可能是搜不完所有点：

```text
0123
*
**
***
```

当 dfs 到 $2$ 节点时，发现只能走到 $0$ 或者 $1$ 了，直接和 $3$ 节点说再见。

我们可以纠正这个做法。

当我们从 $S$ 开始 dfs 直到两个出边都被 vis 过的点 $x$ 时，我们证明 $x$ 必然有一条出边指向 $S$，也就是可以构成一个环，但是不一定覆盖点全集。

证明：

我们确定的边一定是某一个 $(\Delta)$ 的子图，所以相当于我们在这个 $(\Delta)$ 子图上跑搜索，而这个子图是环的不交并，所以我们必然搜出一个环。

然后我们类比求欧拉回路的思路，在求完这个环回溯时记录环上点编号入栈，当回溯到一个点时它可以走另一条边到一个没有 vis 过的点时我们就分叉去 dfs。

（回溯入栈最后答案输出从栈顶开始）

我们证明了这样分叉出去必然会搜一个环出来，然后由于我们回溯入栈，所以从答案序列来看我们相当于在这个分叉出去的点进行了 $(1)(2)$ 连边的交换。

而分叉出去的 dfs 还会再分叉，由 $(*)$，又由于所以我们得到的结果 vis 了点的全集，即答案。

[说起来烦但是代码很简单](https://codeforces.com/contest/325/submission/174738571)

你以为就结束了？

发现上述的做法代码虽然简单但是推导复杂，我们尝试另辟蹊径，做法来自 @[wsyear](https://www.luogu.com.cn/user/169574)。

我们尝试构造一个图使得这个图的欧拉回路等价于原图的哈密顿回路。

差不多可以说是点边互换。

新图长这样：

$m$ 个点 $0,\dots,m-1$，$x$ 点连向 $2x\bmod m$ 一条权值为 $2x$ 的边，向 $(2x+1)\bmod m$ 连一条权值为 $2x+1$ 的边。

我们发现新图中 $x$ 编号的边走完后能紧接着走 $y$ 编号的边当且仅当原图中 $x$ 点有直接指向 $y$ 的有向边，证明不难。

我们发现这个新图的点就是上面做法的组合，边就是两种连边方式，多么殊途同归！

然后求一个欧拉回路，依次输出边的编号即可。

[代码](https://codeforces.com/contest/325/submission/174754127)

累，完结撒花，卑微求赞。