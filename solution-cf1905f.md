# CF1905F Field Should Not Be Empty

除了排序好的答案为 $n-2$，其他必定交换更优。

不妨设交换使得 $i$ 位置变得合法：

* 交换位置不含 $i$，则必然是 $i$ 位置前恰有一个值比它大，同时后面恰有一个比它小，将这两个位置交换了。
* 交换位置含 $i$，则必然是 $i,a_i$ 这两个位置交换了。

综上至多 $2n$ 种交换，求答案取最大值即可。可以用 `std::map` 维护第一类交换中间有多少位置会变为合法。

什么时候能想到枚举一个变得合法的位置来讨论。