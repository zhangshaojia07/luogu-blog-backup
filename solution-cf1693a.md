# CF1693A Directional Increase

神 A 就是结论题，我不活啦 qwq。

首先我们先想想只有**一去一回**，发现是**位置 $1$ 加一，某右边的位置减一**。

接着我们扩展到这道题。发现其实这样的一个回路必然可以分解成几个这样的**一去一回**，只不过左端点可能不是 $1$。

注意这里的分解指的是拥有同样的效果，因为从路径上来看，回路可能在一去一回中途跑去做别的任务然后再回来的。

所以我们得到了条件：

**作 $\{a\}$ 的后缀和，满足 $a_i\le 0(1\le i\le n)$ 且 $a_1=0$。**

然后就做完了……吗？

首先我们把 $\{a\}$ 后缀的极长连续 $0$ 去除。

我们发现如果除 $a_1$ 外有别的 $a_x=0$，则 $[1,x-1]$ 和 $[x,n]$ 形成了两个连通块，也就是说虽然 $[x,n]$ 中正负可抵消，但是我们过不去啊！

所以最终的充要条件：

**作 $\{a\}$（除后缀极长 $0$ 段后）的后缀和，满足 $a_i<0(2\le i\le n)$ 且 $a_1=0$。**

```cpp
int n,a[N];
void work(){
	cin>>n;
	For(i,1,n) cin>>a[i];
	while(n && !a[n]) n--;
	if(!n){
		cout<<"Yes"<<endl;
		return ;
	}
	Rof(i,n-1,1) a[i]+=a[i+1];
	if(a[1]!=0){
		cout<<"No"<<endl;
		return ;
	}
	For(i,2,n){
		if(a[i]>=0){
			cout<<"No"<<endl;
			return ;
		}
	}
	cout<<"Yes"<<endl;
}
```