# P1232 [NOI2013] 树的计数

感觉题解区很大一部分人直接贺别人题解的。

注意这道题儿子顺序是固定的。（dfs 和 bfs）

以下 bfn 指 bfs 序，dfn 指 dfs 序。

显然树高等于 bfs 层数，所以我们将点按 bfn 重新编号（这样 bfn 变成 $1,\dots,n$），将点权置为其 dfn。

题目要求：对于所有合法的 bfn 分段，段数的期望值。

这里合法定义为：

* 每一段点权递增。（因为同一层 dfs 遍历时肯定是从左往右的）

* 每一对 $i,j$，$j$ 的点权比 $i$ 大 $1$，$i,j$ 要么在同一段里，要么在相邻段里。

如果我们把 bfn 分段（即每个点深度）确定了，那树形态也确定了。

而合法的 bfn 分段必然存在一种树，所以段数期望值就是答案。

我们先将 bfn 中相邻点点权不递增的间隙先判为要分段。

然后对于合法的第二个条件，即 bfn 序列中一段内最多有一个分段，若区间已经跨段了就将剩下的间隙设为不可分段（通过差分做到线性）。

剩下的话就直接放了，每一个期望 $0.5$。

```cpp
int n,b[N],id[N],dfn[N],a[N],c[N],ans=1,cnt=0;
//ans=1: 当前树高已经是 1 了，每断裂一次就 +1
//cnt: 断不断随意的间隙个数
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin>>n;
	rep(i,1,n) cin>>id[i];
	int x;
	rep(i,1,n) cin>>x,b[x]=i;
	rep(i,1,n) id[i]=b[id[i]];
	rep(i,1,n) dfn[id[i]]=i;
	//通过点标号的置换，我们保证了 bfs 序是 1...n
	//a[i]:点 i 和点 i+1 之间的标记（的差分）
	rep(i,1,n-1){
		c[i]=c[i-1];
		if(i==1 || dfn[i]>dfn[i+1]){//根之后 / dfn 非递增，必然要断开新成一行
			a[i]++;
			a[i+1]--;
			c[i]++;
			ans++;
		}
	}
	rep(i,1,n-1){
		int j=id[dfn[i]+1];//dfs 序下一个点
		if(j>i){//跳到了 bfs 序更大的点，i,j 之间最多一个间隙断裂
			if(c[j-1]!=c[i-1]){//中间已经有断裂了
				assert(c[j-1]-c[i-1]==1);
				a[i]++;
				a[j]--;
			}
			//否则就没事，原因见下
		}
	}
	//由于每行 dfn 递增，所以行内 dfn 差为 1 的必然相邻
	//这样这类限制就无用了，剩下断不断随意，期望 1/2
	rep(i,1,n-1){
		if(!a[i]) cnt++;
		a[i+1]+=a[i];
	}
	cout<<fixed<<setprecision(3)<<ans+.5*cnt<<"\n";
return 0;}
```