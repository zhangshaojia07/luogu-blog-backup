# CF1616E Lexicographically Small Enough

### Preface

尝试了一上午 $O(n)$ 解法，失败了 qwq，因为区间修改 + 单点查询不可能是线性的。

### Analysis

**注意，以下字符串下标从 $1$ 开始标号，字符集大小 $26$ 当常数看待。**

显然枚举最终 $s$ 和 $t$ 的最长公共前缀长度 $len$，则：

$$\begin{cases}s_i=t_i &i\le len\\s_i>t_i &i=len+1\end{cases}$$

我们从左往右依次增加 $len$，当要使得 $s_{len+1}=t_{len+1}$ 即 $len$ 加 $1$ 时，贪心地选择 $s$ 中 $len$ 右边（或本身就是）距离最近的值为 $t_{len+1}$ 的位置，一步一步调到 $s_{len+1}$ 的位置。

在固定的 $len$ 中，使得 $s_{len+1}>t_{len+1}$ 的贪心方案也与上文类似。

前文的寻找最近位置可以用栈（队列、vector 也行）单次 $O(1)$ 实现。重要的是如何维护 $s$ 中一步一步调度的修改。我们开一个数组 $\{c\}$（用树状数组实时维护），$c_i$ 表示原序列 $s$ 中第 $i$ 位的值现在的位置与 $len$ 的差。若过程中将原序列 $s$ 中第 $i$ 位调换到现在 $len+1$ 的位置上，则 $len$ 增加时 $\{c\}$ 中 $[i,n]$ 区间减 $1$（因为他们没动，而 $len$ 向右了一格， $i$ 之前的因为循环右移也跟着 $len$ 向右一格，所以相对距离不变）。

### Detail

$\{c\}$ 树状数组由于要区间修改 + 单点查询，具体使用了差分。

为了确定每次更新 $len$ 后 $s_{len+1}$ 的值，记录一个数组 $\{vis\}$ 表示对应原始 $s$ 中的这个元素是否被“抛到前面去”了。

### Code

外层循环枚举的 $i$ 实际上是 $len+1$。

[Link](https://codeforces.com/contest/1616/submission/145041309)